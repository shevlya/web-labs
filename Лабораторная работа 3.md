# Лабораторная работа №3
В данной лабораторной работе и в дальнейшем нам понадобятся две новые сущности. 

## Сущность «Пользователь»
Добавьте в базу данных таблицу Пользователь со следующими столбцами:
- id (bigserial) – идентификатор пользователя;
- username (varchar(100)) – логин пользователя;

## Сущность «Роль»
Создайте таблицу Роль со следующими столбцами:
- id (bigserial) – идентификатор роли;
- name (varchar(50)) – имя роли.

## Связи
Свяжите «Пользователь» и «Роль» связью многие ко многим. После создания новых таблиц сделайте столбец createdBy в таблице «Задача» внешним ключом на таблицу «Пользователь».

Создайте напрямую в базе роли ROLE_ADMIN, ROLE_USER. Создайте по одному пользователю с правами ADMIN и USER.

## Обновление зависимостей
Добавьте в pom.xml зависимость spring-boot-starter-data-jpa.
## Создание JPA Entities
Реализуйте JPA сущностные классы для задачи, пользователя и роли. У сущности задачи должна быть ссылка на создавшего её пользователя.

У сущности пользователя должна быть ссылка на список задач и список ролей.

## Слой доступа к данным
Удалите реализации InMemory / JDBC репозиториев с прошлых лабораторных работ. Мы могли бы продолжать их поддерживать далее, но это уже будет замедлять темп повествования.

### TaskRepository
Наследуйте интерфейс `TaskRepository` от `JpaRepository`. Удалите из интерфейса `TaskRepository` все методы, которые уже есть в `JpaRepository`. Оставьте только те методы, которых нет в `JpaRepository` и которые вы реализуете самостоятельно.
Реализуйте:
- метод получения задач с фильтрацией по дате создания и id пользователя через `@Query` аннотацию с `nativeQuery=true`;
- метод получения количества активных задач пользователя (передаём по-прежнему `userId`) через `@Query` аннотацию и JPQL.

### UserRepository
В рамках подготовки к следующей лабораторной работе реализуйте также репозиторий работы с пользователем с одним пользовательским методом: получение пользователя по username. Реализовать через Query method.

### Data Transfer Object (DTO)
На данном этапе попробуйте протестировать контроллер задачи. Возникают ли какие-то ошибки? По какой причине?
Реализуйте DTO класс для пользователя, который будет возвращать в точности такой же контракт полей как и в прошлых работах. Процесс перевода сущности в DTO должен быть реализован в сервисном слое.
Поменяйте в контроллере использование `Task` на `TaskDto`.

## Контрольные вопросы
1) Что такое ORM? Какую проблему решает Object-Relational Mapping?
2) В чём разница между JPA и Hibernate?
3) Почему у JPA репозиториев есть интерфейс, но нет реализации?
4) Как работает Query Method в Spring Data JPA?
5) В чём отличие JPQL от нативного SQL? Когда использовать nativeQuery=true?
6) Концепция DTO.
7) Назначение всех аннотаций, добавленных на сущностный класс и его поля.
