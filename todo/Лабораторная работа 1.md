# Лабораторная работа № 1
## Подготовка проекта
Для создания заготовки проекта воспользуйтесь сервисом [Spring Initializr](https://start.spring.io):
- Project: Maven;
- Language: Java;
- Spring Boot: 4.x.x
- Dependencies: Spring Web;
- Group: ru.ssau;
- Artifact: todo

Также установите себе [JDK](https://openjdk.org), подходящий под выбранную версию Spring.

Для начала работы с приложением необходимо установить библиотеки Spring и все сопутствующие зависимости. Список зависимостей, необходимых для работы приложения, прописывается в файле pom.xml. 

Для управления зависимостями используется maven. Maven автоматически скачает требуемые зависимости при запуске следующей команды в корне вашего проекта: `mvn clean install`. 

Если вы отдельно не устанавливали себе maven, то при генерации заготовки проекта поставляется скрипт mvnw. Тогда команда модифицируется в следующую: `mvnw clean install`.

### Структура проекта
Исходные коды программы размещаются по следующему пути: `/src/main/java/ru/ssau/todo`. Рекомендуется сразу разделять приложение на пакеты. 

Для сущностных классов создать пакет `entity`, для репозиториев — `repository` и т.д.

Конфигурационные файлы размещаются в `/src/main/resources`. Конфигурационный файл понадобится во время выполнения второй лабораторной работы.
## Сущность "Задача"
Реализовать класс `Task` со следующими полями:
- `id (long)` - уникальный идентификатор задачи;
- `title (string)` – название задачи. Обязательное поле;
- `status (TaskStatus)` – статус задачи. Обязательное поле;
- `createdBy (long)` – идентификатор пользователя, создавшего задачу;
- `createdAt (LocalDateTime)` – дата и время создания задачи. Должен генерироваться системой автоматически.

Создайте перечисление `TaskStatus`:
- `OPEN` – открыта;
- `DONE` – сделана;
- `IN_PROGRESS` – в процессе выполнения;
- `CLOSED` – закрыта.
## Слой доступа к данным
Для разделения ответственности выделите логику хранения существующих задач в отдельный слой, называемый репозиторием.
### Интерфейс TaskRepository
Создать интерфейс TaskRepository:
```java
/**
 * Интерфейс репозитория для управления жизненным циклом сущностей {@link Task}.
 * Обеспечивает абстракцию над механизмом хранения данных.
 */
public interface TaskRepository {

    /**
     * Сохраняет новую задачу в хранилище.
     * При сохранении репозиторий обязан присвоить задаче уникальный идентификатор.
     *
     * @param task объект задачи для сохранения (без ID).
     * @return сохраненный экземпляр задачи с назначенным идентификатором.
     * @throws IllegalArgumentException если передана пустая задача (null).
     */
    Task create(Task task);

    /**
     * Выполняет поиск задачи по её уникальному идентификатору.
     *
     * @param id уникальный идентификатор задачи.
     * @return {@link Optional}, содержащий найденную задачу, 
     * или пустой Optional, если задача с таким ID не найдена.
     */
    Optional<Task> findById(long id);

    /**
     * Возвращает список всех задач конкретного пользователя, созданных в указанном временном диапазоне.
     *
     * @param from   начальная граница даты создания (включительно).
     * @param to     конечная граница даты создания (включительно).
     * @param userId уникальный идентификатор пользователя-владельца.
     * @return список задач, соответствующих критериям поиска. Если ничего не найдено, возвращается пустой список.
     */
    List<Task> findAll(LocalDateTime from, LocalDateTime to, long userId);

    /**
     * Обновляет данные существующей задачи в хранилище.
     * Поиск записи для обновления осуществляется по полю ID, содержащемуся в объекте task.
     *
     * @param task объект задачи с обновленными данными.
     * @throws Exception (специализированное исключение) если задача с таким ID не существует.
     */
    void update(Task task) throws Exception;

    /**
     * Удаляет задачу из хранилища по её идентификатору.
     *
     * @param id идентификатор задачи, которую необходимо удалить.
     */
    void deleteById(long id);

    /**
     * Подсчитывает количество "активных" задач для конкретного пользователя.
     * Активной считается задача, находящаяся в статусе OPEN или IN_PROGRESS.
     *
     * @param userId идентификатор пользователя.
     * @return количество активных задач.
     */
    long countActiveTasksByUserId(long userId);
}
```
### Реализация репозитория
Создайте класс `TaskInMemoryRepository`, реализующий интерфейс `TaskRepository`.

Требования:
- используйте `Map<Long, Task>` для хранения задач. Ключ — идентификатор задачи, значение — сама задача;
- класс должен быть помечен аннотацией `Repository`;
- идентификатор задачи должен генерироваться автоматически. Генерация осуществляется путем увеличения счетчика последней сгенерированной задачи, начиная с единицы.

## Слой контроллеров
Создать класс TaskController.
Пометить класс аннотацией `RestController` с базовым путём `/tasks`.

Реализуйте в данном классе следующие эндпоинты. Эндпоинт - метод, вызываемый спрингом при обращении к определенному HTTP ресурсу.
В теле метода должен быть вызван соответствующий метод `TaskRepository`. Для получения объекта репозитория объявите в классе контроллера конструктор, принимающий объект типа TaskRepository.
Сохраните этот объект в соответствующее поле. Далее обращайтесь к нему как к обычному полю класса.

### Инструмент для тестирования API
Существует множество программ, предназначенных для тестирования API - отправка различных http-запросов к приложениям, получение и проверка ответов.
Популярными инструментами являются:
- [postman](https://www.postman.com);
- curl;
- [HttpYac](https://httpyac.github.io);
- [VS Code RestClient](https://github.com/Huachao/vscode-restclient);
- [Insomnia](https://insomnia.rest);
- у IntellIJ есть свой rest клиент. Можете найти информацию в интернете.

Можете выбрать любой инструмент на ваш вкус. Ключевое требование здесь - в момент сдачи у вас должны быть подготовленные запросы, демонстрирующие работу каждого метода.

### Получение списка
Метод: GET

URL: `/tasks?from={from}&to={to}&userId={userId}`

Тело запроса: отсутствует

Параметры запроса:
-  userId (long) — фильтр по владельцу задач.
- from (ISO DateTime, опционально) — начальная дата для поиска (поле createdAt).
- to (ISO DateTime, опционально) — конечная дата для поиска (поле createdAt).

Если параметры from/to не переданы, то используйте дефолтные значения. Например, мы можем подставить время от сотворения мира до далекого будущего.

Ответ при успехе:
- Код: 200 OK
- Тело: JSON-массив объектов задач (возможно, пустой)
### Получение задачи по идентификатору
Метод: `GET`

URL: `/tasks/{id}`

Параметры пути:
- id – числовой идентификатор задачи (long)

Тело запроса: отсутствует

Возможные ответы:
- 200 OK + JSON-объект задачи – если задача найдена
- 404 Not Found – если задача с таким id не существует
### Создание новой задачи
Метод: POST

URL: `/tasks`

Тело запроса: JSON с полями title и status, createdBy

Поля id и createdAt игнорируются, даже если переданы

Ответ при успехе:
- Код: 201 Created
- Заголовок: Location: `/tasks/{новый_id}`
- Тело: JSON созданной задачи
### Обновление задачи
Метод: `PUT`

URL: `/tasks/{id}`

Параметры пути:
- `id` — идентификатор задачи, которую нужно обновить

Тело запроса: JSON с полями `title` и `status`

Поле `id` из тела игнорируется — используется только из URL

Возможные ответы:
- 200 OK — задача успешно обновлена
- 404 Not Found — если задача с указанным id не найдена
- Игнорировать поле id из тела запроса. Использовать переменную пути
- Если задачи с таким идентификатором не найдено, то вернуть 404
### Удаление задачи
Метод: `DELETE`

URL: `/tasks/{id}`

Параметры пути:
- id — идентификатор задачи

Ответ:
Всегда 204 No Content — независимо от того, существовала задача или нет
### Количество активных задач
Активными считаются задачи со статусом `OPEN/IN_PROGRESS`

Метод: `GET`

URL: `/tasks/active/count?userId={userId}`

Параметры запроса:
- `userId` — числовой идентификатор пользователя, задачами которого мы интересуемся

Ответ при успехе:
- Код: 200 OK
- Тело: число (long) — количество активных задач
## Задание на понимание HTTP протокола
Отправьте один запрос через curl с включенным verbose флагом. Вы должны быть способны объяснить назначение каждой части HTTP запроса.
## Контрольные вопросы
1) Опишите структуру HTTP-запроса и HTTP-ответа. Перечислите обязательные и опциональные компоненты.
2) Приведите классификацию HTTP-кодов ответа (1xx, 2xx, 3xx, 4xx, 5xx).
3) Какой HTTP-заголовок определяет формат данных в теле запроса? Какой заголовок определяет формат данных в теле ответа?
4) Что такое JSON? Какие типы данных поддерживаются в JSON?
5) Что такое REST архитектурный стиль? Перечислите ключевые принципы REST. Что понимается под ресурсом в контексте REST?
6) Какая библиотека в Spring Boot отвечает за автоматическое преобразование JSON в Java-объекты и обратно?
7) Продемонстрируйте запросы, возвращающие коды 200, 201, 204, 404.
8) Продемонстрировать представление любого объекта, выдуманного преподавателем, в формате JSON.

