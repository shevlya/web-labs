# Лабораторная работа №4

## Обновление базы данных
Измените базу данных, добавив пользователю поле пароль. Также обновите сущностный класс пользователя, добавив новое поле.

## Обновление зависимостей
Добавьте зависимость spring-boot-starter-security.

## Реализация сервиса работы с пользователями
Создайте класс `CustomUserDetailsService`, реализующий интерфейс [UserDetailsService](https://docs.spring.io/spring-security/reference/api/java/org/springframework/security/core/userdetails/UserDetailsService.html). Реализуйте метод `loadUserByUsername`, загрузив пользователя из нашей базы данных.

Создайте DTO для работы с пользователем. DTO должен содержать следующие поля:
- id (long);
- username (String);
- password (String).

Добавьте в сервис `CustomUserDetailsService` метод регистрации пользователя. Данный метод принимает на вход объект UserDto. В методе необходимо преобразовать объект DTO в сущность USER, зашифровать пароль и сохранить в Б.Д. Назначайте пользователю роль USER если username не admin, иначе — ADMIN. 

## Контроллер пользователя
Создайте контроллер пользователя с базовым путём `/users` с:
- POST `/register`, принимающий на вход объект DTO и регистрирующий пользователя в системе при помощи сервиса `CustomUserDetailsService`.
- POST `/login`, возвращающий DTO пользователя (сугубо логин и роли). На вход принимает логин и пароль пользователя, проверяет, есть ли такой пользователь. Если верификация не удалась, то возвращаем ошибку.

## Конфигурация Security
Создайте конфигурационный класс, содержащий фабричный метод для бина `SecurityFilterChain`.

Реализуйте ролевой доступ к нашей системе:
- `/users/register` и `/users/login` не требует входа в систему;
- `DELETE /tasks/{id}` требует права администратора;
- все остальные эндпоинты для авторизованных пользователей.

Подключите нашу реализацию `UserDetailsService` в фабрике `DaoAuthenticationProvider`. 

## Получение текущего пользователя
Поменяйте контроллер задач: при создании задачи заполняйте поле `createdBy` на основе текущего авторизованного пользователя, а не на основе переданного в теле запроса идентификатора.

## Способы аутентификации
В конфигурационном файле включите авторизацию Basic / Form. Продемонстрируйте оба способа в postman. Объясните, как передаются данные пользователя в каждом способе.

Включите логирование Security, передав debug=true в аннотацию EnableWebSecurity. Проследите цепочку фильтров, вызывающихся при выполнении запроса. Объясните назначение фильтров.

Выполните один защищённый запрос и по логам определите:
‐ какие фильтры были применены,
‐ на каком этапе происходит аутентификация,
‐ на каком этапе принимается решение об авторизации.

## Контрольные вопросы
1) В каком виде передаётся логин и пароль при Basic аутентификации?
2) Как работает сессионная аутентификация? В чём её отличие от токена?
3) В каком виде необходимо хранить пароли в базе данных?
4) Что делает аннотация @Bean, @Configuration?
5) Что такое BCrypt? Чем он отличается от MD5/SHA256?
6) В чём разница между аутентификацией и авторизацией? Продемонстрируйте в программе где происходит то и другое.
7) Продемонстрируйте как получить ответы с кодами 401, 403, 404.
8) Что такое фильтр в Spring Security?

